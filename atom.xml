<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SeaBaby</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fengxru.cn/"/>
  <updated>2018-05-18T05:21:48.767Z</updated>
  <id>http://fengxru.cn/</id>
  
  <author>
    <name>SeaBaby</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于网格的运动统计，用于快速、超鲁棒性的匹配</title>
    <link href="http://fengxru.cn/2018/05/16/GMS-Grid-base%20Motion%20Statistics%20for%20Fast%EF%BC%8CUltra-robust%20Feature%20Correspondence/"/>
    <id>http://fengxru.cn/2018/05/16/GMS-Grid-base Motion Statistics for Fast，Ultra-robust Feature Correspondence/</id>
    <published>2018-05-16T01:54:41.793Z</published>
    <updated>2018-05-18T05:21:48.767Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frd3ed5h5jj30dw07twf9.jpg" alt=""><br> <a id="more"></a></p><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>今天分为两个部分讲解：</p><ol><li>关于Feature Matching 的介绍，可能有些人对feature matching本身不太了解。</li><li>最近几年关于关于feature matching的文章，主要有三篇。</li></ol><p>前两篇文章主要的工作是：把feature matching做的特别的robust，之前的一些作法可能能基本的实现基本的match，但是因为match的质量不高，导致很多应用是不能用的，比如三维重构。但是经过前两篇文章，就可以实现之前不能实现的了，提升了鲁棒性，具有了很大的提高。该篇文章主要是对前两篇文章的优化，因为前两篇虽然最终效果很好，但是速度很慢。对于三维重构来说速度勉强可以，但是对于机器人导航、SLAM、无人机这些应用来说，速度就不够了，作者就对这个问题进行了时间的优化，最终达到的效果就是：性能和前两篇文章实现的相近，时间提升了很多，很快。希望能把这个算法应用到更多实时应用上。</p><h2 id="Feature-Matching-Introduction"><a href="#Feature-Matching-Introduction" class="headerlink" title="Feature Matching Introduction"></a>Feature Matching Introduction</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1frcwu3y7i5j30gi05w44b.jpg" alt=""></p><p>我们可以看一下这两张图，图中山峰是同一个山峰，但是是由人由两个角度进行拍照。所以我们如果能把两张图片中对应的点找来，找出来有什么用呢？我们知道上面的两幅图是由人从不同的角度拍照得来的，那么这两幅图中间是有一个几何关系，这个几何关系可以由一个方程来表示。那么每一个匹配点就相当于这个方程的解，如果我们有足够多的正确匹配的点，我们就可以用这些点来估算这个方程里面的参数，相当于我们知道了两张图片中对应的几何关系</p><h3 id="Correct-Correspondences的应用"><a href="#Correct-Correspondences的应用" class="headerlink" title="Correct Correspondences的应用"></a>Correct Correspondences的应用</h3><p>你把两张图片中相同的点匹配起来有什么用？</p><ul><li>Geometry between 2 views，Geometry就是两张图片中的几何关系，这样我们便可以用来做很多事情：比如：Estimate Camera Pose Localization(SFM)、Tracking(SLAM):就是你能把一帧一帧图像之间的相对应的几何关系能算出来，如果很准的话，你就能画出来人运动的轨迹，就是一个人导航问题。</li><li>Similarity（Number of matches），根据Feature matching的多少评测两张图片的相似度。然后我们就可以用来做Image Retrieval(图像检索)、Object Recognition(目标识别)、Loop Closing(SLAM)….</li></ul><h3 id="如何实现Feature-Matching"><a href="#如何实现Feature-Matching" class="headerlink" title="如何实现Feature Matching"></a>如何实现Feature Matching</h3><p>就是在两张Image中相同的这些部分找到，再把它们匹配起来。</p><ol><li>首先是如何找到，包含两个步骤：Detection、Description。<ul><li>Detection：首先找到的是角点，再者比较容易找的是边缘的点。</li><li>Description：对于这些每一个点计算出周围的特征，比如sift是用128维的数字去描述他的一个description。</li><li>matching的时候，只要用这个128维的数字计算跟哪个点的距离最小，就是最相似的</li><li>Geometry：你拿到这些点的匹配后，去做一个他们之间的相关的几何匹配，模拟几何关系，符合这个几何关系的就是正确匹配的点，不符合的就是错误的点。有了几何关系就可以坐后面的事情了。</li></ul></li></ol><p>LIFT：是用深度学习做的，他认为用深度学习得到的feature比手动提取的feature 更加有用</p><p>Matching Algorithms：CODE、RepMatch、GMS。因为Brute-Force和Approximate（FLANN）所获取的匹配点是杂乱的，大量的，这样你最后算几何关系就会很慢，效果还不好。我们这些Matching Algorithms算法是用来从Nearest-Nerighbor match中找出正确的匹配点，错的剔除去。</p><h3 id="如何估计两张图片之间的几何关系"><a href="#如何估计两张图片之间的几何关系" class="headerlink" title="如何估计两张图片之间的几何关系"></a>如何估计两张图片之间的几何关系</h3><p>一般用的是RANSAC-based方法。</p><p>RANSAC：Random Sample Consensus，它是根据一组包含异常数据的样本数据集，计算出数据的数据模型参数，得到有效样本数据的算法。</p><p>RANSAC也做了一下假设：给定一组（通常很小的）局内点（符合最优模型的点为局内点，不符合的定义为据外点），存在一个可以估计模型参数的过程而该模型能够解释或者适用于局内点 </p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frcxgtq6ehj30vk0guju0.jpg" alt=""></p><p>一个简单的例子就是从一组观测数据中找到合适的2维直线。假设检测到的数据如上图左图。简单的最小二乘法不能找出适应与局内点的直线，原因是最小二乘法尽量去适应包括局外点在内的所有的点。相反，RANSAC能够得出一个仅仅用局内点计算出模型，并且概率还足够高。但是RANSAC并不能保证结果一定正确，为了保证算法有足够搞得合理概率，我们必须小心的选择算法的参数。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxhlslf4j30jq0dy3zu.jpg" alt=""></p><p>在我们的Feature matching里面，它的RANSAC就不是一条直线了，而是两张图片中的几何关系。这里有两个普遍的几何关系：</p><ul><li>Fundamental Matrix（for 3D scenes）：Point to Line(weak, general)<br>只能是点对线的匹配，就是给定第一张图片中的一个点，它会在第二张图片中画出这个点所在的线。<em>能把一个点和一条线对应起来，这就是它们之间的几何关系，这个几何关系能够恢复出来相机的旋转和平移，用的方法主要是RANSAC方法</em></li><li>Homography (for 2D scenes)：Point to Point（strong，narrow range）<br>只对2D场景有效，比如你拍一张墙的照片，然后对其中一个点，就能匹配到第二张图片的点。</li></ul><h2 id="Recent-Robust-Matchers"><a href="#Recent-Robust-Matchers" class="headerlink" title="Recent Robust Matchers"></a>Recent Robust Matchers</h2><h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE [1]"></a>CODE [1]</h3><blockquote><p>该算法解决的是 wide-baseline matching问题。</p></blockquote><h4 id="wide-baseline-matching-？"><a href="#wide-baseline-matching-？" class="headerlink" title="wide-baseline matching ？"></a>wide-baseline matching ？</h4><p>基线的本意是指立体视觉系统中量摄像机光心之间的距离。一句拍摄两幅图，像的视点位置可将对应点匹配问题分为宽基线和窄基线。宽基线一词用于匹配时，泛指两幅图像有明显不同的情况下匹配。产生这种情况的原因有可能为摄像机之间的位置相差很大，也有可能由于摄像机旋转或焦距的变化等因素产生。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1frcxjfh009j30oa0lw1kx.jpg" alt=""></p><p>每一幅图片中的其实是两幅图片，图片中的墙是相同的一个墙，只是由于拍摄的角度特别的大，传统的一些算法处理的不是很好，但是code算法可以，匹配的比较多，准确率也比较高</p><h4 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxjrpjtxj30s00lok26.jpg" alt=""></p><p>整体思想如上图，包含了三个回归模型，likelihood是第一个模型，affine motion 为第二第三个模型。这些回归模型就相当于分类器。</p><ol><li>首先输入的是 Selected matches ，就是先挑一些比较好的match，把它们记录下来，去fit第一个模型，其实就相当于是一个分类器，然后用这个分类器把所有match做一个过滤，符合这个的留下来，不符合的剔除。</li><li>然后再用后面两个模型（即分类器）去过滤，最后都通过的才算最终正确的匹配点。</li></ol><p>这三个回归是怎么做的？看下图（回归模型）</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1frcxkf79soj30ms07iwj2.jpg" alt=""></p><p>有一堆散的点，用这些数据去fit一个平面，这个平面上的你认为是对的，不在这个平面上，你认为是错误的。这样的regression总共有三步。</p><h5 id="Likelihood"><a href="#Likelihood" class="headerlink" title="Likelihood"></a>Likelihood</h5><ul><li>train data：是我们选出来的那些好的match</li><li>test data：是所有的的match</li><li>features of a correspondence：把每一个match点定义为8位的向量，x,y是它的空间位置，dx，dy描述了它的motion，就是一对match点，左右各有一个点，用第二个点（第二幅图）的x2 减去 第一个点x1得到dx。T1-T4是一个矩阵的变换。我们看到的是点对点的匹配，其实是区域的匹配，这四个参数就是描述了左边的这个小区域到右边的对应的小区域的变换。</li><li>Label：我们开始初始化为都是1，认为都是对的。</li><li>Non-linear Optimization：描述了所有correspondence之间的相似性，相似性大的就是1，小的就是0</li></ul><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxkwi8wxj30pg07iwg0.jpg" alt=""></p><p>likelihood模型为什么有用，它就是用来区分连续的Motion和不连续的Motion，作者认为不连续的Motion一般就是错的。第一个模型就是找那些correspondened是连续的。第二个模型就是把它的精度提升了一下，把x和y都预测了一下。作者认为 (a) (b) 这样的图像中的点是正确的点，而像 (c) 这两个比较近的点的方向还差这么大，就认为是错的。第一个模型likelihood就是找到连续的motion，那些点的motion是连续的。<br>第二个模型就是提升了它的精度，把x和y都测了一下。</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>code算法的input就是那个Nearest Neighbor match，它里面是乱七八糟，所有的match都有，而code就是把其中的对的找出来。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxlbkbtij30yo0kye81.jpg" alt=""></p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxmak1twj30yg0g0h0y.jpg" alt=""></p><p>主要是三维重构，你上面第二幅图是用商业软件做的，并不是很好，第三幅是用SFM做的，第四幅还是用SFM做的，但是它把SFM中的Feature matching替换成CODE算法得出的feature matching，效果就好很多。</p><h4 id="Run-time-comparison"><a href="#Run-time-comparison" class="headerlink" title="Run time comparison"></a>Run time comparison</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frcxmocctwj30uo0fo41r.jpg" alt=""></p><p>纵轴是时间表示，以 s 为单位，横轴是matches的数量，可以看到code运行的时间要比其他的好很多，但是对于slam ，机器人导航，一秒钟要读取几十帧，code这个算法的时间还是不够的。</p><h3 id="RepMatch-2"><a href="#RepMatch-2" class="headerlink" title="RepMatch [2]"></a>RepMatch [2]</h3><blockquote><p>基于第一个算法之上，解决一个重复结构（repeated structure）的问题。它是用第一个算法的输出，然后在这个输出上再做一次优化，筛选一些对的点。</p></blockquote><h4 id="repeated-structure到底是一个什么问题"><a href="#repeated-structure到底是一个什么问题" class="headerlink" title="repeated structure到底是一个什么问题"></a>repeated structure到底是一个什么问题</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frcxni5kc2j310a0a8133.jpg" alt=""></p><p>比如 (a) 图中，我们拍了一栋楼的正面，侧面，反面等照片，然后进行SFM三维重构，发现结果它是给我化成了四个部分，但其实它是一栋楼，就是说三维重构并没有重构出这栋楼。<br>原因：因为（a）图像中的楼的各个面的窗口都很像，你也不能确定正面的窗口和背面的窗口有什么不一样，所以导致一个问题：比如SFM就给你标出四个独立的模型，这明明是一栋楼，它合不起来。主要是因为他们之间错误的匹配太多了，你把楼的前面跟后面匹配在一起，它脑子就乱了，根本不知道这是个什么模型。</p><p> 然后用了RepMatch，就能构造一个完整的模型，周围的每一个点是每一张相片拍照的位置，中间这一圈就是楼的俯视图，你他最后dense  reconstruction的结果就是最右边的图</p><h4 id="Repetitive-Structure（怎么做到的构建成功的）"><a href="#Repetitive-Structure（怎么做到的构建成功的）" class="headerlink" title="Repetitive Structure（怎么做到的构建成功的）"></a>Repetitive Structure（怎么做到的构建成功的）</h4><p>它是建立在CODE 输出结果之上的。它把输出结果分为了几类：</p><ul><li>第一类：</li></ul><h3 id="GMS"><a href="#GMS" class="headerlink" title="GMS"></a>GMS</h3><p>这篇文章主要是把前面两篇文章的主要思想掌握到，然后把它变快，能够把它应用到更多上面。</p><p>首先我们看一个小视频，上面的是作者的GMS算法，下面的是sift，我们可以发现，GMS的match首先在数量上就比sift的多很多，这样我们就能保证最后验证那个几何关系比较准，如果点比较少的话，你做RANSAC的话，就会不稳定，出错之类的。作者的算法比sift这个算法更快更好。</p><h4 id="Motivation：为什么又要质量好又要速度快"><a href="#Motivation：为什么又要质量好又要速度快" class="headerlink" title="Motivation：为什么又要质量好又要速度快"></a>Motivation：为什么又要质量好又要速度快</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frcxo7udm1j312w0l60xv.jpg" alt=""></p><p>最常用的算法可能就是Ratio Test，比较流行，比较快，但是不具备鲁棒性。当前的算法比如code等，效果很好，但是很慢。GMS特点就是：又快又好。</p><p>论文GMS的方法实际上是消除错误匹配的一种方案，比如可以替换ransac。算法执行的大致流程是：先执行任意一种特征点的检测和特征点的描述子计算，论文中采用的是ORB特征。然后执行暴力匹配BF，最后执行GMS以消除错误匹配。</p><h4 id="Key-Idea"><a href="#Key-Idea" class="headerlink" title="Key Idea"></a>Key Idea</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frcxp52no1j310s0dy1kx.jpg" alt="">True matches(green) are visually smooth while false matches(cyan) are not.  </p><p>正确匹配的点我们用绿色的标注出来，错误匹配的点用青涩标注出来。首先我们可以看到正确匹配的点，举个例子，假设随便拿出来两个正确匹配的点（绿色标注的）记为1号点和2号点，1、2号点在另一幅图中对应匹配的点为1‘和2’。我们可以看到1号点对应的匹配点1‘与2号点对应的匹配点2’位置差不多，相似，整个过程是一个比较smooth的过程。而两个相近错误的点（青色的标注），对应的匹配点一个去了楼上，一个去了天上，这就是我们从观察上得到的信息。<em>那么如何把这个观察的信息变成一个算法去验证这个点是对还是不对，这就是算法的核心</em>。</p><p>首先我们说了一个正确的match看起来比较smooth，所以我们有没有办法把这些看起来比较smooth的match提取出来，我们就认为这些match是对的。<br>根据贝叶斯上讲，既然正确的match看起来比较smooth，那么比较smooth的match应该也是正确的。</p><p>Key Idea：核心思想就是我们如何把match中比较smooth的match拿出来。</p><p><em>方法</em>主要分为三部分：</p><ol><li>Motion Statistics：motion统计</li><li>Grid Framework：grid结构是用来加速的</li><li>Motion Kernels：也是用来加速的</li></ol><p>后面两个部分都是为了实现第一个部分Motion统计，让它变得很快。</p><h4 id="Motion-Statistics"><a href="#Motion-Statistics" class="headerlink" title="Motion Statistics"></a>Motion Statistics</h4><h5 id="Motion-Statistics-Model"><a href="#Motion-Statistics-Model" class="headerlink" title="Motion Statistics Model"></a>Motion Statistics Model</h5><p>首先看一下统计模型是怎么样的，对每一个match，比如说match xi，给他左边和右边各画一个圈，数一下圈中还有多少个其他的match</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1frcxq8nm9sj30y20hytw9.jpg" alt=""></p><p>这个有什么道理：如果一个正确的match，它旁边还有正确的match的话，应该是支持它的。（就像之前的图中显示那样，对的，周围一般Motion是相似的）道理就是一个正确的match旁边可能有对的点在帮你，而对于一个错误的match，你的这个错误是随机发生的，你很难再找到一个点跟你犯一样的错误。所以这两个的概率相差非常大的，第一种正确的match这个圈里面总会有一些点来支持它，而错误的match 支持它的点可能有，但是会很少，这就是这个算法的模型。</p><p>这个图中Si就是表示统计值，这张图中Si = 2，Sj是下面那个，没有人支持他，所以是0.<br>所以motion统计就是这样一件事情。</p><p>Si = 2；Sj = 0.</p><h4 id="我们分析一下这个模型为什么对于判断“这个点是否正确”有效"><a href="#我们分析一下这个模型为什么对于判断“这个点是否正确”有效" class="headerlink" title="我们分析一下这个模型为什么对于判断“这个点是否正确”有效"></a>我们分析一下这个模型为什么对于判断“这个点是否正确”有效</h4><p>我们假设一个点的统计值 Si ，</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxqz5w9dj30kw04o3zj.jpg" alt=""><br>它应该服从这个binomial distribution（二项分布）。<br>就假设这个 xi 是正确的的话，那么用 pt 表示这个概率，这个概率是指：假设上图中左边的圈为A，右边的圈为B，那么如果这个点 xi 匹配是正确的话，它周围的点从A到B的可能性是多少，就是支持这个点 xi 的可能性是多少。<br>对于这个 pf ，如果这个 xi 匹配是错的，那么它周围的点支持它的概率是多少。</p><p>我们用 fa 表示 A 这个圈中额外支持它的n个点中的一个点。然后去算这个概率，我们要给出一个事件和假设，如下图：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1frcxrds8qpj30ws09e40k.jpg" alt=""></p><ul><li>第一个事件表示：fa这个点匹配正确，它的概率为 t，这个概率跟这个算法有关，匹配的质量越高，那么这个概率当然要高</li><li>第二个事件表示：fa 这个点匹配错误，它的概率就是 1-t</li><li>第三个事件表示：fa 这个点 匹配到了 B 圈中的一个点（但不一定是正确的）</li></ul><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxroffjfj31040aqac3.jpg" alt=""></p><p>定义这三个事件后，我们给出一个假设：如果一个点它匹配错了，它的匹配还是从A到B的话，那么它的概率是多少 。我们知道如果是A中的一个点匹配错了，那有可能匹配到右边Image中的任何一个点，而它恰好匹配到B圈中的点，如果是随机分布的话，那么这个概率应该为 (m / M), m为B圈中的点的个数，M 为右边图中所有的点的个数。但是可能很多Image是这样的分布，但是有一些Image不是，我们为了弥补这个假设（随机分布），我们给它乘以一个 “贝塔”参数，当这个参数比较大的时候，这个假设就不那么成立了 。这个参数为1的时候，这个假设正好成立。 </p><p>我们算一下这个概率，如下图：<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frcxs4c06oj30tw0i0n1z.jpg" alt=""></p><p>因为m很小，所以 pf 是一个接近 0 的概率。<br>而 pt 是一个接近 t 的数，因为 pf 是接近 0 的数 。所以这两个的差异很大，另外我们要怎么才能让这个差异变得更大？</p><p>我们上面是在两张图中各画了一个小圈AB，这个小的区域中，他们的正确的点motion是连续的，通常一个Image中，不是只有这个一个小的区域中的motion是连续的，更大的区域应该也是连续的。</p><p>比如，之前那张狗的图片，我们只是画了狗的鼻子的一小块区域，但是其实鼻子旁边的区域也是连续的，当然我们不是画整张图片，只是比那个小圈更大一些，所以扩展到了 3*3的这样一个区域，相当于比之前的一个圈扩大了9倍，如下图：</p><p> <img src="https://ws4.sinaimg.cn/large/006tNc79ly1frcxsgt12oj30tk0h0wge.jpg" alt=""></p><p>我们之前只是画了a、b这两个圈，现在我们画了9个这样圈，并且统计这个 3 * 3 这样的区域中的 Si。这样便能增大这个distribution之间的差异，如下图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frcxtro02rj30lm048jsp.jpg" alt=""></p><p>因为是3*3，所以 K=9 ，这个Si的分布中 pt 和 pf 是跟之前的一样的，因为只有K变化了。所以计算一下均值和方差，如下图：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1frcxu00evbj30s803s76e.jpg" alt=""></p><p>这个是后面要用到。</p><p>现在我们分析一下这个模型有什么用</p><h4 id="Analysis-Model"><a href="#Analysis-Model" class="headerlink" title="Analysis Model"></a>Analysis Model</h4><ul><li><p>Partionalbility</p><p>这个词是表示，对的点和错的点之间有多大的差距，看起来在这个模型中有多么不一样。<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxuymvwzj30oe038q3s.jpg" alt=""><br>P就是用来定义这两个分布（错的和正确的分布）的距离。P越大，表示这个错误的点和正确的点看起来越不一样，那么这个模型就越强。 </p></li><li><p>Quantity-Quality equivalence</p></li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1frcxv626d2j30kc02ydfw.jpg" alt=""><br>我们可以看到这个 P 是正比于这个 Kn 的，就是说你用越多的点在里面，那么这个模型就越强，错的点和对的点的区别就越大。</p><ul><li>Relationship to Descriptors</li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1frcxvbftmvj30n402k74p.jpg" alt=""><br>看与这个descriptors的关系，这个descriptors就是 t ，比如你用sift特征点，假如这个sift特征特别强的话，那么这个P是趋近于无穷大的。这就能验证我们的算法是对的。，也比较合乎道理，你特征越强，你越好分割，所以 P 趋近于无穷大。</p><h4 id="Experiments-on-real-data"><a href="#Experiments-on-real-data" class="headerlink" title="Experiments on real data"></a>Experiments on real data</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxwj273hj30g20dy3zs.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frcxx02a4xj30ws046aba.jpg" alt=""><br>该模型在Oxford Affine Dataset上进行评估。 在这里，我们运行SIFT匹配并根据基础事实将所有匹配标记为内点或外点。 我们计算每个匹配的一个小区域内的支持的个数。</p><p>纵轴表示了每个matching旁边画了两个小圈，然后数一数这个小圈中 正确的Inlier周围中到底有多少个点支持它，错的点到底有几个点支持它。</p><p>它有8的小的datasets，每个dataset里面有五对张照片，这五对照片匹配起来<br>一对比一对难，就是越来越难，每个数据，是用8个datasets的数据做了平均得到的。</p><p>所以从上图可以看出：对于正确的点，就算是最难得时候，也有接近8个点支持它，而对于错误的点，始终没有超过1个点支持它。所以可以看出这个模型对于正确的点和错误的点的认识性还是很强的。</p><p>这个算法我们已经知道了，那么如何去加速实现它呢？</p><h4 id="Grid-Framework"><a href="#Grid-Framework" class="headerlink" title="Grid Framework"></a>Grid Framework</h4><p>我们刚才是给每对匹配点画两个圈，一个点一个圈，这样的问题就是：你要想知道有多少个点这个圈内，那你必须要把所有的点过滤一遍。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxxlai2dj31260hmq6m.jpg" alt=""><br>所以现在我们的做法是不要给这个匹配点画圈，我们直接把image 打成网格，然后这个匹配点自然就会落在这个Image的网格中，那么它这个网格就代表他的这个小圈，就没有了两个小圈的匹配，而变成了两个网格的匹配，你只要数一下这个网格中有多少个点跟它一样就可以了。 只要你一开始把这些 Feature matching丢进这些网格中，你很容易数清楚。这样算法的时间复杂度就从O(n) -&gt; O(1). 所以会变得很快。</p><h4 id="Motion-Kernel"><a href="#Motion-Kernel" class="headerlink" title="Motion Kernel"></a>Motion Kernel</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frcxxraymdj30y60l440x.jpg" alt=""><br>因为我们之前已经知道用更多的region会产生更好的结果，因为我们进行统计的时候就变成了统计这九个小网格的正确点的数量就好了，就很容易能数清楚。</p><h4 id="Empirical-parameters（经验参数）"><a href="#Empirical-parameters（经验参数）" class="headerlink" title="Empirical parameters（经验参数）"></a>Empirical parameters（经验参数）</h4><ul><li><p>你用多少个网格？</p><ul><li>太细的话，统计不好</li><li>太粗的话，精度太低</li><li>经验上作者是说用 20 * 20</li></ul></li><li><p>How to set the threshold？怎么设置阈值？<br>就是认为计算出来的这个值（用 τ 表示）过了多少是对的，没过多少是错的。用的是一个平均值加一个方差，这是经验得到的，并没有什么道理可言。<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1frcxy19p42j30ry08sgnk.jpg" alt=""><br>这个 α 参数一般我们设置为 0.6 。</p></li></ul><h4 id="Grid-Motion-Statistics-Algorithm"><a href="#Grid-Motion-Statistics-Algorithm" class="headerlink" title="Grid Motion Statistics Algorithm"></a>Grid Motion Statistics Algorithm</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxy972w1j30pm0ms0zx.jpg" alt=""><br>首先是给定这个 Correspondences（匹配点）、scale、rotation，然后产生这个 Kernel 和 Grid（20 * 20）。确定好了，去计算每一个点的统计值 Si ，然后去计算这个 τ，如果这个 Si &gt; τ，那么这个点就是对的。没过就是错的。</p><h4 id="Full-feature-matching-pipeline"><a href="#Full-feature-matching-pipeline" class="headerlink" title="Full feature matching pipeline"></a>Full feature matching pipeline</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1frcxyged1wj30qy0lkwll.jpg" alt=""><br>这是一个完整的流程，首先获取 feature 然后做 match，然后交给GMS，因为这个scale、rotation可能有多个值，你可以多试几遍，找到一个最好的值。 </p><h4 id="Run-time"><a href="#Run-time" class="headerlink" title="Run time"></a>Run time</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxym1mzzj310y0g2n0h.jpg" alt=""><br>这里是提取10000个点为例。<br>这个值可以再Video上实时的，因为ORB和Nearest neighbor可以并行</p><h4 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1frcxzfbmt4j311e0ncaro.jpg" alt=""></p><p>我们测试了4个dataset，第一个是TUM。做slam的可能知道，下面是6个视频，然后从中提取出很多帧做测试，所以这个数据集上有3000多个照片。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1frcxzgleftj30uw0nm7b4.jpg" alt=""><br>0-30是表示两张图片的角度，就是baseline。至于在Strecha和VGG上，Ratio算法表现并不差，是因为这两个数据集太水了，大家是用来发paper的。像TUM这样真正的应用数据上来看，一般的算法根本就不太行了，质量会很差。 </p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1frcxzial0xj30xk0ow79k.jpg" alt=""><br>X轴是时间，用的是ms表示，Y轴是performance，红色的是作者的算法表现。可以看出GMS实现了结果上差不多，但是时间上快很多倍的效果。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxzjw5f1j311u0p07wh.jpg" alt=""><br>我们从上图可以看出，第一幅图，是在平面上，GMS和SIFT比来看，SIFT经过RANSAC后，结果还是勉强可以的。就是说在平面上，这个sift加上RANSAC结果还是可以的。但是在3D中，sift匹配的全都是错误的点，但是GMS依然是表现很好。说明我们这个算法对于wide-baseline问题是真的解决了，不像sift只有在实验中（那些dataset上）表现的还可以接受，但是在现实中的dataset就不行了。</p><p>再就是解决了重复结构的问题，如下图：<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxzm03dkj311y0jo4qp.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frcxzo7hcrj30yy0oghdt.jpg" alt=""><br>之前我们是假设物体是静止的，但是这些猫狗是会动的，动了之后，你拍的图片用sift去匹配的话，如果有的匹配错，并且没有那些RANSAC方法去帮它修正的，那么你匹配对的就是对的，错的就是错的，没有办法去修改。而作者的算法是可以匹配正确的，根本不需要去修正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79ly1frd3ed5h5jj30dw07twf9.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="论文" scheme="http://fengxru.cn/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="GMS" scheme="http://fengxru.cn/tags/GMS/"/>
    
      <category term="CVPR 2017" scheme="http://fengxru.cn/tags/CVPR-2017/"/>
    
  </entry>
  
  <entry>
    <title>Mac常用快捷键教程</title>
    <link href="http://fengxru.cn/2018/05/08/Mac%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%99%E7%A8%8B/"/>
    <id>http://fengxru.cn/2018/05/08/Mac常用快捷键教程/</id>
    <published>2018-05-08T15:38:49.000Z</published>
    <updated>2018-05-09T05:08:47.192Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fr4czzw6xfj312s0ny4f3.jpg" alt=""></p><a id="more"></a><h2 id="用option快速输入一些特殊符号"><a href="#用option快速输入一些特殊符号" class="headerlink" title="用option快速输入一些特殊符号"></a>用option快速输入一些特殊符号</h2><ul><li>option V： 输入  √</li><li>option /： 输入  ÷</li><li>option =： 输入  ≠</li><li>option &gt;： 输入  ≥</li><li>option &lt;： 输入  ≤</li><li>option K： 输入  ˚</li><li>option X： 输入  ≈</li><li>option =： 输入  ≠</li><li>option 2： 输入 ™</li><li>option R： 输入  ®</li><li>option Y： 输入  ¥</li><li>option P： 输入  π</li><li>option G： 输入  ©</li><li>option + shift + K： </li></ul><h4 id="通知中心开关"><a href="#通知中心开关" class="headerlink" title="通知中心开关"></a>通知中心开关</h4><blockquote><p>按住 option 点击桌面右上角通知中心，即可直接关闭或开启通知。不用在通知中心中打开了。</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fr4dwwsrc0g30gu08mq3t.gif" alt=""></p><blockquote><p>比如用 Mac 全屏看电影又不想被右上角的消息弹出打扰的话，暂时开启勿扰（关闭通知）就是了.</p></blockquote><h4 id="WIFI状态"><a href="#WIFI状态" class="headerlink" title="WIFI状态"></a>WIFI状态</h4><p>按住 option 点击 Wi-Fi 图标即可查看 IP 地址、Wi-Fi 信号强度等等 Wi-Fi 的详细信息。<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fr4dwnmbmuj30hg0nw406.jpg" alt=""></p><h2 id="通用快捷键"><a href="#通用快捷键" class="headerlink" title="通用快捷键"></a>通用快捷键</h2><ul><li>command + M：最小化窗口</li><li>command + H：隐藏窗口</li><li>command + N：新建窗口</li><li>command + O：打开</li><li>command + Shift + S：另存为</li><li>command + P：打印</li><li>command + W：关闭</li><li>command + Q：退出</li></ul><h2 id="文件管理器"><a href="#文件管理器" class="headerlink" title="文件管理器"></a>文件管理器</h2><ul><li>command + I：显示简介</li><li>command + F：搜索</li><li>command + delete：删除</li><li>command + Shift + delete：清空回收站</li><li>option + 方向键左：将光标移动到前一个单词</li><li>command + option + I：查看多个文件一共有多大</li><li>option + 方向键上：将光标移动到当前段落的开头</li><li>command + shift + 方向键左/右：可以选中一句话</li><li>command + 方向键左：将光标移动到句子的开头</li><li>command + 方向键上：将光标快速移动到整篇文本开头</li></ul><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><ul><li>command + +\=：放大</li><li>command + --：缩小</li><li>command + T：新建一个选项卡</li><li>command + N：新建一个新窗口</li><li>command + R：刷新</li><li>command + F：搜索</li><li>command + W：关闭当前选项卡</li><li>command + D：将网页加入个人收藏</li><li>command + Z：恢复刚才关闭的网页</li><li>command + shift + B：显示或隐藏收藏栏</li><li>command + shift + N：打开一个全新的隐私浏览器窗口比较合适</li><li>space / space + shift：向下或向上滚动一整页</li><li>command + option + Q：退出 Safari，在下次打开的时候，会自动加载上次的所有窗口</li><li>option + 方向键上/方向键下：网页向上或向下滚动一整页</li></ul><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><ul><li>command + option + esc：强制退出程序</li><li>command + shift + Y：生成便签</li><li>command + space：切换输入法</li><li>command：按住command即可用鼠标移动拖动顶部图标排列</li><li>control + command + space：快速调出emoji表情和各种特殊符号输入</li><li>shift + option + F1 / F2：可以以1/4格为单位对屏幕亮度调整，音量也是如此。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>后续会继续补充。有什么遗漏的，可以留言。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79ly1fr4czzw6xfj312s0ny4f3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="http://fengxru.cn/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://fengxru.cn/tags/Mac/"/>
    
      <category term="快捷键" scheme="http://fengxru.cn/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>吵架</title>
    <link href="http://fengxru.cn/2018/04/28/2018.4.27/"/>
    <id>http://fengxru.cn/2018/04/28/2018.4.27/</id>
    <published>2018-04-27T16:42:05.682Z</published>
    <updated>2018-05-09T04:16:12.275Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fqrpbkpmtwj31kw0zk49k.jpg" alt=""></p><blockquote><p>今天是怎么了，或者说这几天是怎么了，天天惹你生气，心情很烦躁，我准备开始写日记，抒发一下自己的心情，要不我可能会被憋死的。</p></blockquote><a id="more"></a><h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><p>环顾四周和手机应用，竟然没有一个地方可以让我肆无忌惮的畅所欲言的发泄。在朋友圈、空间、微博你敢发吗，人长大了，总是要顾虑这顾虑那，我不想发在朋友圈后，让你再多想，我只是想找一个地方写写我的心情，要不我可能真的会被郁闷死的。</p><h3 id="回忆中学"><a href="#回忆中学" class="headerlink" title="回忆中学"></a>回忆中学</h3><p>初中时候，我个人的品性很差，现在想想那可能是最灰暗的三年了，没有知心朋友，脾气古怪，小心眼，自己一个人卑微的活着，也不知道打了多少架，现在想想，心中只是一阵痛。我只能说，有时候真的不是我的错，我还记得初中上学时，学校不让住校，我就只能在学校外跟同学合租房子，大约有5、6个人吧。其中有一个是邻班的班长，有天晚上，他就突然找我的茬。有人可能说，人家怎么会莫名其妙的找你的茬，但我可以摸着良心说，我真的没有做错什么。那天晚上，他跟我打了一架，我被揍了，哭着跑了出去，大晚上自己一个人走在马路上，一个人哭，最终我还是去给我妈妈打了个电话，最终的结果就是，我妈妈来了学校，他妈妈也来了学校，和解。后来我才知道，他为什么要跟我打架，因为他想让他一个好朋友住进来，把我踢出去，现在想起来我还是很痛恨他。</p><h3 id="事情原委"><a href="#事情原委" class="headerlink" title="事情原委"></a>事情原委</h3><p>话扯远了，今天晚上也不知道为啥心情这么暴躁，刚开始和你打游戏时的心态可能就不对，最后因为我想用法师貂蝉，而队伍中已经有个法师，你就说别让我用法师，换个吧。我当时可能心情就很不爽了，因为之前打了几局都不好，然后就反驳，最后凶了你一句，然后我们就各删了游戏。呵呵，然后就在微信上聊了起来，你说你哭了，觉得自己很委屈，只不过是玩个游戏，我就凶你了，那以后生活的不得水深火热。我当时心中还很烦躁，我这个人要是心情烦躁起来，就不会讲理了。</p><p>聊着聊着，我就问了你一句：“现在后悔还来得及”，其实说完这句话，我很还忐忑，我心中在期待，你肯定的回答，但是没有。但也不意外，毕竟都在气头上，而且还是我的错。</p><p>我很害怕失去你，又不想表达出来，想听你心中最真实的想法，我自己心中的想法是“你要是想离开，我不会挽留”，因为你既然都想好了，我不想要个勉强的你。</p><h3 id="自我反省"><a href="#自我反省" class="headerlink" title="自我反省"></a>自我反省</h3><p>话说回来，也该批评自己了，最近是很膨胀啊。毕竟这几年过得都顺风顺水，没什么大的坎坷，可能自己在心态上就有了变化，脾气也见长了，价值观也有了变化，喜欢购物，花钱，穿好看的。没有了高中那种一花钱就想到父母的辛苦。我觉得这样很不好，我要改变自己，虽然之前删游戏是一时之快，但是我想坚持下来，把更多的时间用在学习上。</p><h4 id="改进之处"><a href="#改进之处" class="headerlink" title="改进之处"></a>改进之处</h4><ul><li>把更多的时间花在学习和陪你上</li><li><p>脾气暴躁需要改改，以后多读书，去图书馆借本自控力的书，每天阅读半个小时</p></li><li><p>爱说脏话，这个要改，但是没啥很好的方法，就平时多自己注意吧</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自己写完这些字，心情果然好了点。继续加油，明天会是美好的一天！加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79ly1fqrpbkpmtwj31kw0zk49k.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今天是怎么了，或者说这几天是怎么了，天天惹你生气，心情很烦躁，我准备开始写日记，抒发一下自己的心情，要不我可能会被憋死的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="心情笔记" scheme="http://fengxru.cn/categories/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="丹岑" scheme="http://fengxru.cn/tags/%E4%B8%B9%E5%B2%91/"/>
    
      <category term="心情" scheme="http://fengxru.cn/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://fengxru.cn/2017/11/07/hello-world/"/>
    <id>http://fengxru.cn/2017/11/07/hello-world/</id>
    <published>2017-11-07T15:46:15.000Z</published>
    <updated>2018-05-09T05:06:22.250Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fl9vx0z3xpj30l30bugll.jpg" alt=""></p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using <a id="more"></a>Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79ly1fl9vx0z3xpj30l30bugll.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iTerm 2 实用快捷键</title>
    <link href="http://fengxru.cn/2017/11/02/iTerm%202%20%E5%AE%9E%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://fengxru.cn/2017/11/02/iTerm 2 实用快捷键/</id>
    <published>2017-11-02T15:47:44.000Z</published>
    <updated>2018-05-09T04:20:59.161Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fl9vptkwalj314m0eejv7.jpg" alt=""></p> <a id="more"></a><ul><li>⌘ + Click：可以打开文件，文件夹和链接</li><li>⌘ + n：新建窗口</li><li>⌘ + t：新建标签页</li><li>⌘ + w：关闭当前页</li><li>⌘ + 数字 &amp; ⌘ + 方向键：切换标签页</li><li>⌥⌘ + 数字：切换窗口</li><li>⌘ + enter：切换全屏</li><li>⌘ + d：左右分屏ß</li><li>⇧⌘ + d：上下分屏</li><li>⌘ + ;：自动补全历史记录</li><li>⇧⌘ + h：自动补全剪贴板历史</li><li>⌥⌘ + e：查找所有来定位某个标签页</li><li>⌘ + r &amp; ⌃ + l：清屏</li><li>⌘ + /：显示光标位置</li><li>⌥⌘ + b：历史回放</li><li>⌘ + f：查找，然后用 tab 和 ⇧ + tab 可以向右和向左补全，补全之后的内容会被自动复制， 还可以用 ⌥ + enter 将查找结果输入终端</li><li>选中即复制，鼠标中键粘贴</li></ul><p>很多快捷键都是通用的，和 Emace 等都是一样的</p><ul><li>⌃ + u：清空当前行</li><li>⌃ + a：移动到行首</li><li>⌃ + e：移动到行尾</li><li>⌃ + f：向前移动</li><li>⌃ + b：向后移动</li><li>⌃ + p：上一条命令</li><li>⌃ + n：下一条命令</li><li>⌃ + r：搜索历史命令</li><li>⌃ + y：召回最近用命令删除的文字</li><li>⌃ + h：删除光标之前的字符</li><li>⌃ + d：删除光标所指的字符</li><li>⌃ + w：删除光标之前的单词</li><li>⌃ + k：删除从光标到行尾的内容</li><li>⌃ + t：交换光标和之前的字符</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1fl9vptkwalj314m0eejv7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="http://fengxru.cn/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://fengxru.cn/tags/Mac/"/>
    
      <category term="iTem2" scheme="http://fengxru.cn/tags/iTem2/"/>
    
  </entry>
  
  <entry>
    <title>密钥分发中心（KDC）</title>
    <link href="http://fengxru.cn/2017/11/02/%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91%E4%B8%AD%E5%BF%83%EF%BC%88KDC%EF%BC%89/"/>
    <id>http://fengxru.cn/2017/11/02/密钥分发中心（KDC）/</id>
    <published>2017-11-02T15:46:15.000Z</published>
    <updated>2017-11-07T14:17:11.959Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fl9vriv380j30rs0kuads.jpg" alt=""></p><h3 id="简言"><a href="#简言" class="headerlink" title="简言"></a>简言</h3><blockquote><p>密钥分发中心是一种运行在物理安全服务器上的服务，KDC维护着领域中所有安全主体账户信息数据库。</p><p>与每一个安全主体的其他信息一起，KDC存储了仅安全主体和KDC知道的加密密钥，这个密钥也称长效密钥（主密钥），用于在安全主体和KDC之间进行交换。</p></blockquote> <a id="more"></a><blockquote><p>KDC是作为发起方和接收方共同信任的第三方，因为他维护者一个存储着该域中所有账户的账户数据库，也就是说，他知道属于每个账户的名称和派生于该账户密码的Master Key（主密钥）。而用于Alice和Bob相互认证的会话密钥就是由KDC分发的，下面详细讲解KDC分发会话密钥的过程。</p></blockquote><h3 id="分发会话密钥过程"><a href="#分发会话密钥过程" class="headerlink" title="分发会话密钥过程"></a>分发会话密钥过程</h3><p>1、首先客户端向KDC发送一个会话密钥申请。这个申请的内容可以简单概括为”我是某客户端，我需要个Session Key用于与某服务器通话“。</p><p>2、KDC在接收到这个请求的时候，生成一个会话密钥。为了保证这个会话密钥仅仅限于发送请求的客户端和它希望访问的服务器知道，KDC会为这个会话密钥生成两个副本，分别被客户端和服务器使用。然后从账户数据库中提取客户端和服务器的主密钥分别对这两个副本进行对称加密。对于服务器，与会话密钥一起被加密的还包含关于客户端的一些信息，以便对发起连接请求的客户端进行身份认证。</p><pre><code>注意：KDC不是直接把这两个会话密钥副本分发客户端和服务器的，因为如果这样做，对于服务器来说会出现下面两个问题。由于一个服务器会面对若干不同的客户端，而每个客户端都具有一个不同的Session Key。那么服务器就会为所有的客户端维护这样一个会话密钥的列表，这样对服务器来说工作量就非常 大了。由于网络传输的不确定性，可能会出现这样一种情况：客户端很快获得会话密钥用于副本，并将 这个会话密钥作为凭据随同访问请求发送到服务器，但是用于服务器的会话密钥却还没有收到，并且很 有可能这个会话密钥永远也到不了服务器端，这样客户端将永远得不到认证。为了解决这个问题， Kerberos将这两个被加密的副本一同发送给客户端，属于服务器的那份由客户端发送给服务器。因为 这两个会话密钥副本分别是由客户端和服务器端的主密钥加密的，所以不用担心安全问题。</code></pre><p>3、通过上面的过程，客户端实际上获得了两组信息：一个是通过自己主密钥加密的会话密钥；另一个是被Server的主密钥加密的数据包，包含会话密钥和关于自己的一些确认信息。在这个基础上，我们再来看看服务器是如何对客户端进行认证的。</p><p>4、客户端通过用自己的主密钥对KDC加密的会话密钥进行解密从而获得会话密钥，随后创建认证符（Authenticator，包括客户端信息和时间戳（Timestamp）），并用会话密钥对其加密。最后连同从KDC获得的、被服务器的主密钥加密过的数据包（客户端信息和会话密钥）一并发送到服务器端。我们把通过服务器的主密钥加密过的数据包称为服务票证（Session Ticket）。</p><p>5、当服务器接收到这两组数据后，先使用它自己的主密钥对服务票证进行解密，从而获得会话密钥。随后使用该会话密钥解密认证符，通过比较由客户端发送来的认证符中的客户端信息（Client Info）和服务票证中的客户端信息实现对客户端身份的验证。</p><p>双方进行了身份认证的同时也获得了会话密钥，那么双方可以进行会话了。</p><p>流程图如下：</p><p>客户端简称为Alice，服务端简称为Bob</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fk4ams2bxcj30tw0buab9.jpg" alt=""></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><a href="http://book.51cto.com/art/200907/140554.htm" target="_blank" rel="external">参考文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79ly1fl9vriv380j30rs0kuads.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;简言&quot;&gt;&lt;a href=&quot;#简言&quot; class=&quot;headerlink&quot; title=&quot;简言&quot;&gt;&lt;/a&gt;简言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;密钥分发中心是一种运行在物理安全服务器上的服务，KDC维护着领域中所有安全主体账户信息数据库。&lt;/p&gt;
&lt;p&gt;与每一个安全主体的其他信息一起，KDC存储了仅安全主体和KDC知道的加密密钥，这个密钥也称长效密钥（主密钥），用于在安全主体和KDC之间进行交换。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://fengxru.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="KDC" scheme="http://fengxru.cn/tags/KDC/"/>
    
      <category term="密钥" scheme="http://fengxru.cn/tags/%E5%AF%86%E9%92%A5/"/>
    
  </entry>
  
</feed>
