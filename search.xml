<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[吵架]]></title>
    <url>%2F2018%2F04%2F28%2F2018.4.27%2F</url>
    <content type="text"><![CDATA[今天是怎么了，或者说这几天是怎么了，天天惹你生气，心情很烦躁，我准备开始写日记，抒发一下自己的心情，要不我可能会被憋死的。 前序环顾四周和手机应用，竟然没有一个地方可以让我肆无忌惮的畅所欲言的发泄。在朋友圈、空间、微博你敢发吗，人长大了，总是要顾虑这顾虑那，我不想发在朋友圈后，让你再多想，我只是想找一个地方写写我的心情，要不我可能真的会被郁闷死的。 回忆中学初中时候，我个人的品性很差，现在想想那可能是最灰暗的三年了，没有知心朋友，脾气古怪，小心眼，自己一个人卑微的活着，也不知道打了多少架，现在想想，心中只是一阵痛。我只能说，有时候真的不是我的错，我还记得初中上学时，学校不让住校，我就只能在学校外跟同学合租房子，大约有5、6个人吧。其中有一个是邻班的班长，有天晚上，他就突然找我的茬。有人可能说，人家怎么会莫名其妙的找你的茬，但我可以摸着良心说，我真的没有做错什么。那天晚上，他跟我打了一架，我被揍了，哭着跑了出去，大晚上自己一个人走在马路上，一个人哭，最终我还是去给我妈妈打了个电话，最终的结果就是，我妈妈来了学校，他妈妈也来了学校，和解。后来我才知道，他为什么要跟我打架，因为他想让他一个好朋友住进来，把我踢出去，现在想起来我还是很痛恨他。 事情原委话扯远了，今天晚上也不知道为啥心情这么暴躁，刚开始和你打游戏时的心态可能就不对，最后因为我想用法师貂蝉，而队伍中已经有个法师，你就说别让我用法师，换个吧。我当时可能心情就很不爽了，因为之前打了几局都不好，然后就反驳，最后凶了你一句，然后我们就各删了游戏。呵呵，然后就在微信上聊了起来，你说你哭了，觉得自己很委屈，只不过是玩个游戏，我就凶你了，那以后生活的不得水深火热。我当时心中还很烦躁，我这个人要是心情烦躁起来，就不会讲理了。 聊着聊着，我就问了你一句：“现在后悔还来得及”，其实说完这句话，我很还忐忑，我心中在期待，你肯定的回答，但是没有。但也不意外，毕竟都在气头上，而且还是我的错。 我很害怕失去你，又不想表达出来，想听你心中最真实的想法，我自己心中的想法是“你要是想离开，我不会挽留”，因为你既然都想好了，我不想要个勉强的你。 自我反省话说回来，也该批评自己了，最近是很膨胀啊。毕竟这几年过得都顺风顺水，没什么大的坎坷，可能自己在心态上就有了变化，脾气也见长了，价值观也有了变化，喜欢购物，花钱，穿好看的。没有了高中那种一花钱就想到父母的辛苦。我觉得这样很不好，我要改变自己，虽然之前删游戏是一时之快，但是我想坚持下来，把更多的时间用在学习上。 改进之处 把更多的时间花在学习和陪你上 脾气暴躁需要改改，以后多读书，去图书馆借本自控力的书，每天阅读半个小时 爱说脏话，这个要改，但是没啥很好的方法，就平时多自己注意吧 总结自己写完这些字，心情果然好了点。继续加油，明天会是美好的一天！加油！]]></content>
      <categories>
        <category>心情笔记</category>
      </categories>
      <tags>
        <tag>丹岑</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F25%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88Machine%20Learning%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是机器学习（Machine Learning） 对于一个适当的学习问题，计算机程序从经验E中学习，解决某一任务T进行某一性能度量P，通过P测定在T上的表现因经验E而提高 机器学习算法主要分为两类： Supervised learning Unsupervised learning other：强化学习和推荐系统 Supervised Learning监督学习是指，我们给算法一个数据集，其中包含了正确答案，算法的目的是为了得到更多的正确答案。 比如我们给了一个一个房屋面积和对应的正确房价的数据集，然后为你的朋友想要卖掉的这所房子进行估价。 回归是指：我们设法预测连续值得属性。 分类是指：我们设法预测一个离散值输出。 Unsupervised Learning在监督学习中数据集中的每个样本都清晰地标明了什么是所谓的正确答案和错误答案。 但是在无监督学习中，我们所用的数据和之前不同，数据集中的每个样本没有任何的标签，或者说都具有相同的标签、没有标签等。那么有这样一个数据集，我们不知道拿它来做什么，也不知道每个数据是什么，我们只被告知这里有一个数据集，你能在其中找到某种结构吗。 对于如上图这样的数据集，无监督学习算法可能判定该数据集包含两个不同的簇，无监督学习可以把这些数据分成两个不同的簇，这就是聚类算法。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F13%2F%E5%85%AD%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%AD%89IPV6%E8%B5%84%E6%BA%90%E4%B8%8A%E4%B8%8D%E5%8E%BB%E7%9A%84%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题描述 前一段时间我也是出现这个问题，六维空间上不去，IPV6网站打开慢，IPV6网络电视看不了。开始以为是六维在线人数太多的原因，可偶然还原系统后发现又能上了，第二天又不行了。。。后来经过baidu google等等终于解决。 解决办法首先，这与TJU–PT 无关，目前TJU–PT走的是IPV4，所以对IPV6不会有影响。然后，这种方法只是适用于多个IPV6地址冲突引起的问题。最后，解决方法如下： 开始 –&gt; 运行 –&gt; cmd –&gt; ipconfig 正确结果应如下 Connection-specific DNS Suffix . : IP Address. . . . . . . . . . . . : 202.113..（IPV4地址） Subnet Mask . . . . . . . . . . . : 255.255.255.0 IP Address. . . . . . . . . . . . : 2001:da8:a000:141:::: （IPV6地址） IP Address. . . . . . . . . . . . : fe80::21f:29ff:feae:42b4%4 Default Gateway . . . . . . . . . : 202.113.186.1 fe80::20f:e2ff:feb3:950a%4 （IPV6网关） 如果 Connection-specific DNS Suffix . : IP Address. . . . . . . . . . . . : 202.113..（IPV4地址） Subnet Mask . . . . . . . . . . . : 255.255.255.0 IP Address. . . . . . . . . . . . : 2001:da8:a000:141:::: （IPV6地址） IP Address. . . . . . . . . . . . : 2001:da8:a000:141:48c6:5545:381c:d4ed （多余的IPV6地址，该地址只是例子，具体不定） IP Address. . . . . . . . . . . . : fe80::21f:29ff:feae:42b4%4 Default Gateway . . . . . . . . . : 202.113.186.1 fe80::20f:e2ff:feb3:950a%4 （IPV6网关） 应该把多余的IPV6地址删除 开始–运行–cmd–netsh–interface–ipv6–delete address “本地连接” 2001:da8:a000:141:48c6:5545:381c:d4ed 注:如出现”连到系统上的设备没有发挥作用”是正常的，不用管，继续下一步 然后设置IPV6地址，避免再次被自动分配，又会有多个IPV6地址 开始–运行–cmd–netsh–interface–ipv6–add address “本地连接” 2001:da8:a000:141:::: 重启即可，以后每次你的IPV6地址就固定为2001:da8:a000:141::::了。 以下来自chanshi1988，上述方法不行的同学可以试试 从网上找到了另外一种方法，可以一劳永逸解决生成临时地址的问题： 在系统中启用IPv6后，系统会出现两个地址，一个为学校分配的正式地址，另一个为系统自行生成的临时地址。该临时地址的生成会向网络中发布数据 包，占用网络资源，影响网络健康。 所以，请大家关闭此项功能。 操作如下： 开始-〉运行-〉输入netsh -〉输入int ipv6 -〉输入set privacy state=disable 成功后，再次查看 ipconfig信息，不会出现IPv6临时地址了。 ifconfig | grep inet6| awk ‘{print “ifconfig eth0 inet6 del”,$3}’]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F02%2F28%2F%5BLeetCode%5D%20Palindrome%20Number%2F</url>
    <content type="text"><![CDATA[[LeetCode] Palindrome Number题目讲解 Determine whether an integer is a palindrome. Do this without extra space. 该题目意思是判断一个整数是否为回文数字，并且不能使用额外的空间。 题目分析那么首先要搞清楚什么是回文数字？回文数字就是正着读和反着读是一样的数字，比如说121、12321等。乍一看我感觉这道题很简单，只需要将该整形数字转为字符串，然后反转，与原字符串进行比较，如果相等则是回文数字，否则不是。 那么程序如下： 12345678public boolean isPalindrome(int x) &#123; String str = x + &quot;&quot;; StringBuffer sb = new StringBuffer(str.toString()); // 利用Java中reverse函数对字符串进行反转，然后比较 String str_res = sb.reverse().toString(); return str_res.equals(str); &#125; 但是我们忽略了题目中的一个要求：不能使用额外的空间，上面的转为字符串，进行反转，不符合这个要求，因为我们把反转的字符串赋值给了一个字符串变量，这样就使用了额外的空间。 编程实现第一种解题思路：依次比较数字的第一位和最后一位、数字的第二位和倒数第二位、、、 12345678public static boolean IsPalindorme(int x) &#123; for (int i = 0; i &lt;= Integer.toString(x).length() / 2; i++) &#123; if (Integer.toString(x).charAt(i) != Integer.toString(x).charAt(Integer.toString(x).length() - i - 1)) &#123; return false; &#125; &#125; return true; &#125; 第二种 反转比较法1解题思路：回文数有一个特性，就是反转后与原值是相等的。所以我们可以先将该值反转，然后比较原值与反转值是否相等，该方法在于溢出的判断与处理，我们可以使用long来保存可能溢出的结果。 123456789101112131415public static boolean IsPalindorme(int x) &#123; // 解题思路： // 1. x &lt; 0 , x 不是回文 // 2. x &gt;=0 , 将x反转得到反转值，比较反转值与x，如果相等，则x是回文数。注意，要防止反转后溢出，所以用long long reverse = 0, original = x; if (x &lt; 0) return false; while (x &gt; 0) &#123; reverse *= 10; reverse += x % 10; x /= 10; &#125; return reverse == original; &#125; 第三种 反转比较法2解题思路：思路与第二种相似，也是将数字反转，然后将反转值与原数值比较是否相等，因为此时可能会遇到溢出问题，第二种方法用long类型解决，我们其实还可以用另外的方法解决。我们仅仅比较原数的一半，即比较原数的前一半和后一半是否相等，关键在于我们如何知道我们已经反转了数字的后一半了，当原数值小于反转数值时，就已经证明我们已经处理了一半的数字了。 123456789101112131415161718192021222324public static boolean IsPalindorme(int x) &#123; // 解题思路：将数字本身还原，就是将数字反转过来，比较与原来的数字是否相等。但是可能会遇到溢出问题， // 在第二种解法中，我们用了long类型的变量，其实我们也可以恢复数字的一半，比如1221，我们只将最后两位21恢复为12，然后与前两位12比较是否相同 // 考虑如何恢复数字的后半部分。如数字1221，如果做 1221%10=1 得到数字的最后一位。 // 为了得到倒数第二位数字，我们可以将 1221的最后一位删除掉，可以用1221除以10，1221 / 10 = 122,然后 122 % 10 = 2，这样便得到了1221的倒数第二位数字。 // 我们将得到的倒数第一位数字 * 10 + 倒数第二位数字，即 1 * 10 + 2 = 12。如果想还原更多的数字，继续这个过程，我们可以还原更多的数字 // 但是关键在于我们如何知道我们已经还原了数字的一半，因为我们是用还原的数字与原数字比较，看是否相等。 // 当原始数字（12）小于&quot;倒数&quot;（即还原的数字12）时，此时我们已经处理了一半的数字. // 当 x &lt; 0;或者 x 最后一位为0且 x != 0 时，返回false if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) return false; int rev = 0; while (x &gt; rev) &#123; rev = rev * 10 + x % 10; x /= 10; &#125; // 当 x 的长度为奇数时，我们可以通过 rev % 10 消除中间数字 // 比如12321，当while循环结束时，x = 12， rev = 123， // 因为中间数字3在回文中并不重要，它怎么反转，因为长度为奇数，而且它在中间，所以如何反转，它一直在中间不会变，所以我们可以简单地进行消除 return (x == rev || x == rev / 10); &#125; 第四种 逐位比较法解题思路：反转比较有可能会溢出，但我们遍历每一位的时候其实并不用保存上一位的信息，只要和当前对应位相等就行了。所以我们可以遍历一遍先算出数的长度，再遍历一遍同时对比前后的对应位。 12345678910111213141516171819202122232425262728293031public static boolean IsPalindorme(int x) &#123; // 逐位比较：反转可能会造成溢出，其实我们遍历每一位的时候并不用保存上一位的信息，只要和当前位相等就行了。 // 1. x &lt; 0,则返回false // 1. 我们先算出该整数大小的级数，比如x=1234，那么该整数大小的级数dight = 1000 // 2. 用 x%dight 等于x的首位msd，用 x%10 等于x的末尾lsd，如果 msd != lsd，则返回false，否则全部相等，则返回true if (x &lt; 0) &#123; return false; &#125; int dight = 1, orginal = x; // 计算当前树的位数，个数位不用计算，默认为1 while (x &gt; 9) &#123; x /= 10; dight *= 10; &#125; x = orginal; while (x &gt; 0) &#123; int msd = x / dight; int lsd = x % 10; if (msd != lsd) &#123; return false; &#125; // 去除最高位 x -= msd * dight; x /= 10; dight /= 100; &#125; return true; &#125; 总结其实我还是不太明白这个不使用额外空间的要求到底什么意思，只是查了网上的博客，每个人都说是不能使用将该数字转为字符串然后反转比较的方法。如果有人能很好地理解这个，希望可以留言。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F02%2F26%2F%5BLeetCode%5D%20String%20to%20Integer%20(atoi)%20%2F</url>
    <content type="text"><![CDATA[【LeetCode】String to Integer (atoi)题目描述 Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Requirements for atoi: The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 分析问题一开始我刚看到这个题目时，本身英语不好的我就没有弄清楚这道题到底想让我们干点什么（主要是我太渣了。。。。）。经过查阅别人的博客后，终于弄清楚这个题目的要求。 这道题就是让一个字符串中第一个非空字符，然后从这个字符开始，后面尽可能跟随多的数字，并将它们最后解释为数字值。简单的来说，就是从这个字符串的第一个非空字符开始查找，找到第一个数字，一直找到不是数字为止，就是让你编写这样一个函数：输入为一个字符串，输出为一个int类型的数字。比如：输入字符串为”abc123df“，那么输出为123；再比如”asd-123“，那么输出为123。但是还需要有以下几种情况需要特殊对待： 如果字符串开头是空白字符即空格，要跳过空白字符，一直到第一个非空白字符，如果字符串为空，则返回0 如果数字前面有正负号，即+、-，如果只有一个正负号，则标记该数字的正负号，如果有两个或者更多，则返回0.比如+-1、-+1这两种情况则返回0 如果下一个字符不是数字，则返回0.不考虑小数点和自然数的情况 若下一个字符为数字，则转为整形保存下来，若接下来再有非数字出现，则返回现在的数值 还需要考虑边界问题，如果超过了整形的边界值，则用边界值代替 代码实现1234567891011121314151617181920212223public static int myAtoi(String str) &#123; // 1.判断是否为空字符串 if (str.isEmpty()) return 0; int i = 0, sign = 1, base = 0, n = str.length(); // 2.去除字符串中空白字符 while (i &lt; n &amp;&amp; str.charAt(i) == &apos; &apos;) ++i; // 3.确定正负 if (str.charAt(i) == &apos;+&apos; || str.charAt(i) == &apos;-&apos;) sign = (str.charAt(i++) == &apos;+&apos;) ? 1 : -1; while (i &lt; n &amp;&amp; str.charAt(i) &gt;= &apos;0&apos; &amp;&amp; str.charAt(i) &lt;= &apos;9&apos;) &#123; if (base &gt; Integer.MAX_VALUE / 10 || (base == Integer.MAX_VALUE / 10 &amp;&amp; str.charAt(i) - &apos;0&apos; &gt; 7)) return (sign == 1) ? Integer.MAX_VALUE : Integer.MIN_VALUE; base = base * 10 + (str.charAt(i++) - &apos;0&apos;); &#125; return base * sign; &#125; 总结这道题目，就我个人来说，理解起来有点困难，可能做得题目太少了。还需要注意的是需要考虑的情况不要少。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[iTerm 2 实用快捷键]]></title>
    <url>%2F2017%2F11%2F02%2FiTerm%202%20%E5%AE%9E%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[⌘ + Click：可以打开文件，文件夹和链接 ⌘ + n：新建窗口 ⌘ + t：新建标签页 ⌘ + w：关闭当前页 ⌘ + 数字 &amp; ⌘ + 方向键：切换标签页 ⌥⌘ + 数字：切换窗口 ⌘ + enter：切换全屏 ⌘ + d：左右分屏ß ⇧⌘ + d：上下分屏 ⌘ + ;：自动补全历史记录 ⇧⌘ + h：自动补全剪贴板历史 ⌥⌘ + e：查找所有来定位某个标签页 ⌘ + r &amp; ⌃ + l：清屏 ⌘ + /：显示光标位置 ⌥⌘ + b：历史回放 ⌘ + f：查找，然后用 tab 和 ⇧ + tab 可以向右和向左补全，补全之后的内容会被自动复制， 还可以用 ⌥ + enter 将查找结果输入终端 选中即复制，鼠标中键粘贴 很多快捷键都是通用的，和 Emace 等都是一样的 ⌃ + u：清空当前行 ⌃ + a：移动到行首 ⌃ + e：移动到行尾 ⌃ + f：向前移动 ⌃ + b：向后移动 ⌃ + p：上一条命令 ⌃ + n：下一条命令 ⌃ + r：搜索历史命令 ⌃ + y：召回最近用命令删除的文字 ⌃ + h：删除光标之前的字符 ⌃ + d：删除光标所指的字符 ⌃ + w：删除光标之前的单词 ⌃ + k：删除从光标到行尾的内容 ⌃ + t：交换光标和之前的字符]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>iTem2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密钥分发中心（KDC）]]></title>
    <url>%2F2017%2F11%2F02%2F%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91%E4%B8%AD%E5%BF%83%EF%BC%88KDC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简言 密钥分发中心是一种运行在物理安全服务器上的服务，KDC维护着领域中所有安全主体账户信息数据库。 与每一个安全主体的其他信息一起，KDC存储了仅安全主体和KDC知道的加密密钥，这个密钥也称长效密钥（主密钥），用于在安全主体和KDC之间进行交换。 KDC是作为发起方和接收方共同信任的第三方，因为他维护者一个存储着该域中所有账户的账户数据库，也就是说，他知道属于每个账户的名称和派生于该账户密码的Master Key（主密钥）。而用于Alice和Bob相互认证的会话密钥就是由KDC分发的，下面详细讲解KDC分发会话密钥的过程。 分发会话密钥过程1、首先客户端向KDC发送一个会话密钥申请。这个申请的内容可以简单概括为”我是某客户端，我需要个Session Key用于与某服务器通话“。 2、KDC在接收到这个请求的时候，生成一个会话密钥。为了保证这个会话密钥仅仅限于发送请求的客户端和它希望访问的服务器知道，KDC会为这个会话密钥生成两个副本，分别被客户端和服务器使用。然后从账户数据库中提取客户端和服务器的主密钥分别对这两个副本进行对称加密。对于服务器，与会话密钥一起被加密的还包含关于客户端的一些信息，以便对发起连接请求的客户端进行身份认证。 注意：KDC不是直接把这两个会话密钥副本分发客户端和服务器的，因为如果这样做，对于服务器来说会 出现下面两个问题。由于一个服务器会面对若干不同的客户端，而每个客户端都具有一个不同的Session Key。那么服务器就会为所有的客户端维护这样一个会话密钥的列表，这样对服务器来说工作量就非常 大了。由于网络传输的不确定性，可能会出现这样一种情况：客户端很快获得会话密钥用于副本，并将 这个会话密钥作为凭据随同访问请求发送到服务器，但是用于服务器的会话密钥却还没有收到，并且很 有可能这个会话密钥永远也到不了服务器端，这样客户端将永远得不到认证。为了解决这个问题， Kerberos将这两个被加密的副本一同发送给客户端，属于服务器的那份由客户端发送给服务器。因为 这两个会话密钥副本分别是由客户端和服务器端的主密钥加密的，所以不用担心安全问题。 3、通过上面的过程，客户端实际上获得了两组信息：一个是通过自己主密钥加密的会话密钥；另一个是被Server的主密钥加密的数据包，包含会话密钥和关于自己的一些确认信息。在这个基础上，我们再来看看服务器是如何对客户端进行认证的。 4、客户端通过用自己的主密钥对KDC加密的会话密钥进行解密从而获得会话密钥，随后创建认证符（Authenticator，包括客户端信息和时间戳（Timestamp）），并用会话密钥对其加密。最后连同从KDC获得的、被服务器的主密钥加密过的数据包（客户端信息和会话密钥）一并发送到服务器端。我们把通过服务器的主密钥加密过的数据包称为服务票证（Session Ticket）。 5、当服务器接收到这两组数据后，先使用它自己的主密钥对服务票证进行解密，从而获得会话密钥。随后使用该会话密钥解密认证符，通过比较由客户端发送来的认证符中的客户端信息（Client Info）和服务票证中的客户端信息实现对客户端身份的验证。 双方进行了身份认证的同时也获得了会话密钥，那么双方可以进行会话了。 流程图如下： 客户端简称为Alice，服务端简称为Bob 总结参考文章]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>KDC</tag>
        <tag>密钥</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F10%2F01%2F%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86%E4%BD%93%E7%B3%BB%20%E2%80%94%20DES%2F</url>
    <content type="text"><![CDATA[对称密钥加密体系 — DES 对称密钥加密机制即对称密码体系，也称单玥密码体系和传统密码体系。对称密码体系通常分为两大类：分组密码（如DES、AES算法），另一类为序列密码（如RC4算法）。 对称密码体系加密和解密时所用的密钥是相通的或者是类似的，即由加密密钥很容易推导出解密密钥，反之亦然。对称密钥加密，最大的优势是加/解密速度快，适合对大数据量进行加密，但密钥管理困难。 对于普通的对称密码学，加密运算与解密运算使用同样的密钥。通常使用的对称密钥加密算法比较简单高效，密钥剪短，破译极其困难，由于系统的保密性主要取决于密钥的安全性，，所以在公开的计算机网络上安全的传送和保护密钥时一个严峻的问题。而且由于对称密码学中双方使用相同的密钥，因此无法实现数据签名和不可否认性等功能。 DES加密流程对于任意长的铭文，DES首先对其进行分组，使得每一组的长度为64位，然后分别对每个64位的铭文分组进行加密。对于每个64位长度的明文分组的加密过程如下： 1、初始置换：输入分组按照初始置换表重排次序，进行初始置换。 2、16轮循环：DES对经过初始置换的64位铭文进行16轮类似的子加密过程。每一轮的子加密过程要经过DES的f函数，其过程如下： 将64位明文在中间分开，划为2部分，每部分32位，左半部分记为L，右半部分记为R，以下的操作都是对有半部分数据进行。 扩展置换：扩展置换将32位的输入数据根据扩展置换表扩展称为48位输出数据。 异或运算：将48位的明文数据与48位的子密钥进行异或运算。 S盒置换：S盒置换是非线性的，48位输入数据根据S盒置换表置换成为32位输出数据。 直接置换：S盒置换后的32位输出数据根据直接置换表进行直接置换。 经过直接置换的32位输出数据与本轮的L部分进行异或运算，结果作为下一轮子加密过程中的R部分。本轮的R部分直接作为下一轮子加密过程中的L部分。然后进行下一轮子加密过程，直到16轮全部完成。 3、终结置换：按照终结置换表进行终结置换，64位输出就是密文。 DES加密流程详解DES的分组过程DES是一种分组加密算法，所谓分组加密算法就是对一定大小的明文后密文来做加密或解密动作。在DES加密系统中，每次加密或解密的分组大小均为64位，所以DES没有密文扩充的问题。对大于64位的明文只要按每64位的一组进行切割，而对于小于64位的明文只要在后面补“0”即可。 DES所用的加密或解密密钥也是64位大小，但因其中有8个位时奇偶校验位，所有64位中真正起密钥作用的只有56位，密钥过短也是DES最大的缺点。 初始置换经过分组后的64位明文分组将按照初始置换表重新排列次序，进行初始置换，置换方法如下：初始置换表从左到右，从上到下读取，如第一行第一列为58，意味着将原文分组中的第58位置换到第一位，初始置换表下一个数位50，意味着将原明文分组的第50位置置换到第2位，依次类推，将原明文分组的64位全部置换完成。 表1.1初始化置换表 58 50 42 34 26 18 10 2 60 52 44 36 28 20 12 4 62 54 46 38 30 22 14 6 64 56 48 40 32 24 16 8 57 49 41 33 25 17 9 1 59 51 43 35 27 19 11 3 61 53 45 37 29 21 13 5 63 55 47 39 31 23 15 7 扩展置换32位的有半部分明文数据首先要进行扩展置换，扩展置换将32位输入数据扩展成为48位的输出数据，他有三个目的：第一，它产生了与子密钥同长度的数据以进行异或运算；第二，它提供劳务更长的结果，使得在以后的子加密过程中能进行压缩；第三，它产生雪崩效应，这也是扩展置换最主要的目的，使得输入的一位将影响两个替换，所以输出对输入的依懒性将传播的更快（雪崩效应）。其实我只明白第一和第三点。。。 扩展置换的置换方法与初始置换相同，只是置换表不同，扩展置换表如下所示： 表1.2 扩展置换表 32 1 2 3 4 5 4 5 6 7 8 9 8 9 10 11 12 13 12 13 14 15 16 17 16 17 18 19 20 21 20 21 22 23 24 25 24 25 26 27 28 29 28 29 30 31 32 1 异或运算扩展置换的48位输出数据与相应的子密钥进行按位异或运算。异或以后的48位结果将继续进行S盒置换。 S盒置换S盒置换是DES算法中最重要的部分，也是最关键的步骤，因为其他运算都是线性的，只有S盒置换是非线性的，它比DES中任何一步都提供了更好的安全性。 经过异或运算得到的48位输出数据要经过S盒置换，置换由8个盒完成，记为S盒，每个S盒都有6位输入，4位输出。这8个S盒是不同的，每个S盒置换方法如下图所示。使用方法如下：48位的输入分成8组，每组6位分别进入8个S盒。将每组的6位输入记为B0、B1、B2、B3、B4、B5，那么表中的行号由B0B5决定，而列号由B1B2B3B4决定。例如第一个分组位111000要进入第一个S盒S1，那么行号位B0B5,即10，化为十进制即2，即第二行；列号位1100（B1B2B3B4），即为第12列，第2行第12列在下表中的S1中查找位数据3，所有这个S和的4位输出就是3，化为二进制即0011. 表1.3 盒置换表 直接置换S盒置换后的32位输出数据将进行直接置换，该置换把每个输入位映射到输出位，任意一位不能映射两次，不能略去。 终结置换终结置换与初始置换相对应，都不影响DES的安全性，主要目的是为了更容易的将明文和密文数据以字节大小放入des的f算法或者DES芯片中。 总结刚刚看计算机网络安全相关知识，这一部分不太明白，所以查了一下，自己顺便记录一下，有什么不对的，大家纠正。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F09%2F18%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式(Singleton Pattern) 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 应用场合：有些对象只需要一个就足够了，如老婆 作用：保证整个应用程序中某个实例有且只有一个 类型：饿汉模式、懒汉模式 三个特性：1、单例类只能有一个实例；2、单例类必须自行创建自己的唯一的实例；3、单例类必须给所有其他对象提供这一实例。 Singleton（单例）：在单例类的内部实现只声称一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为 私有 ；在单例类内部定义了一个Singleton类型的 静态 对象，作为外部共享的唯一实例。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F09%2F18%2Fandroid%20%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[异步消息处理框架1、android 异步消息处理框架2、Handler + Looper + Message异步消息处理框架 非主线程使不能直接设置UI的在异步加载中，我们通常有两种方法来避免ListView的缓存这样一个特性所造成的ListView的Item的错乱或是错位的这样一个现象：1、一个是在BaseAdapter中设置对应的Tag，将一个url或是一个身份验证信息将相应的Item进行绑定，而在真正加载的时候来判断身份验证信息是否正确，只有在正确的时候才会进行设置图片的操作2、第二个就是使用成员变量，将对应的数据进行缓存从而避免由于网络下载时间不确定所导致的一个时序上的混乱，这样一个方式余地一种方式其实是一样的。 Android 异步加载如何提高效率1、ListView滑动停止时才加载可见项2、ListView滑动时，取消所有加载项]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F09%2F18%2F%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[支付宝前台和后台服务器的搭建步骤 Android客户端首界面是为顾客展示一个房型和日期等信息的选择和填写，订单填写完毕后提交到王昊，由王昊进行房型、日期等信息的确认和计算出总金额并返回给客户端或者返回给客户端一个错误代码（error_code=-1,代表该房型已经没有了）。 生成二维码所必须的四个参数（实际传前三个参数）：1、outTradeNo：订单号，必填。用系统时间来充当订单号2、subject：订单名称，必填。用系统时间来充当3、totalAmount：付款金额，必填。王昊返回给客户端的金额4、undiscountableAmount：不可打折金额，可填。默认值为 totalAmount，实际操作时先不写 客户端向指定的的网址发起Post请求，服务器返回给客户端一个该订单的二维码（显示在Android客户端）供顾客扫描支付 服务器端主要是在Servlet中编写生成订单的对应的二维码 当客户扫描Android客户端显示的二维码并付款成功时，在Android客户端需要显示一个该订单是否成功的状态（可用一张图片表示成功，用另外的图片表示失败）1、服务器端调用支付宝提供的查询订单的函数，在Servlet中调用2、客户端还是发起post请求，获取json数据，然后根据获取的json数据判断是否成功。3、顾客填写订单 –&gt; 提交给王昊 —&gt; 收到支付总额，自动生成订单号，传给服务器生成二维码并在客户端上显示 —&gt; 顾客扫描二维码并支付成功后，点击客户端的支付完成按钮 —&gt; 客户端向服务器发起该订单查询，根据查询结果向顾客显示订单结果，如果支付成功，讲传递给王昊，让其调用机械臂取房卡给顾客。 首先要保证手机和电脑在一个局域网下，每一次更换网络环境，需要更改服务器端的MyServlet中的url、客户端的LoadQR、QueryOrder中的url。然后服务器和客户端重新运行。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F09%2F18%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射知识（Reflect） 编译时刻加载类是静态加载类，运行时刻加载类是动态加载类 new创建对象 是静态加载类，在编译时刻就需要加载所有可能使用到的类 动态加载类，在运行时刻加载，Class.forName() 基本的数据类型，比如void、关键字等都存在类类型 成员变量也是对象，是java.lang.reflect.Field的对象 Field类封装了成员变量的操作 方法的反射都是在编译后的操作，即运行时刻的操作]]></content>
  </entry>
</search>
